<?php
if(!defined("USE_HOST"))// условие проверяющее возможность прямого доступа
	die("Прямой доступ запрещен!");// в случае прямого доступа вывод сообщения

class FrontController{
	private $_controller,// имя или экземпляр класса вызываемого контроллера
	$_errorPointsArray = array(),// массив с позициями в массиве _errors с каких проверяется наличие новых ошибок
	$_lastSetErrorKey = "",// ключ массива _errorPointsArray, какой был установлен последним
	$_action,// имя вызываемой модели поведения
	$_page,// сгенерированная страница
	$_view=null,// имя представления, какое используется по умолчанию
	$_isBody=false,// флаг наличия содержимого страницы
	$_defaultController = "",// имя контроллера, вызываемого по умолчанию
	$_errorController = "",// имя контроллера, вызываемого при отсутствии указанного котроллера
	$_routes;// ассоциативный массив с маршрутами, связывающие строку запроса с котроллерами и их методами
	public $_errors = array(),// массив с не критическими ошибками
	$_openRemoteConnect = false,// флаг возможности удаленных системных запросов
	$_needReturn404Error = false,// флаг при котором необходимо передать браузеру заголовки 404-й ошибки
	$_params = array(),// параметры, переданные в строке запроса.
	$_remoteIp = "All",// массив с ip адресами, с каких разрешено выполнять удаленный системный запрос
	$_requestType="none",// тип системного запроса
	$_requestStopText="",// текст критической ошибки, при системном запросе
	$_requestReturnData;// переменная, значение какой передается обратно при системном запросе
	static $_instance;// экземпляр класса FrontController
	public static function getInstance(){// получение экземпляра класса FrontController
		if(!(self::$_instance instanceOf self))// проверка наличия в переменной $_instance экземпляра класса FrontController
			self::$_instance = new self;// создание экземпляра класса FrontController
		return self::$_instance;
	}
	function createErrorPoint($name=false,$offset=false){// метод создания точки, с какой проверять наличие ошибок
		// $name - имя, какое будет установлено для идентификации точки, с какой проверять наличие ошибок
		// $offset - целое число, указывающее, сколько элементов не учитывать с начала массива ошибок
		$offset = (int)$offset;// приведение переменной в целочисленный тип
		if($name===false){//действия, если имя точки не указано
			$name = "systemName";// постоянная часть автоматического имени
			$nameIndex = 0;// изменяемая часть автоматического имени
			while(isset($this->_errorPointsArray[$name."_".$nameIndex])){// действия если автоматическое имя существует
				if($nameIndex>100){// действия при наличие автоматических имен > 100
					$nameIndex = 1;// изменяемой части автоматического имени присваивается 1
					break;// выполняется выход из цикла, для избегания бесконечного цикла
				}
				$nameIndex++;// увеличение изменяемой части автоматического имени на 1;
			}
			unset($nameIndex);
			$name .= "_".$nameIndex;// создание автоматического имени
		}
		$this->_lastSetErrorKey = $name;// сохранение имени как последнего ключа
		$cnt = count($this->_errors);// количество элементов массива с ошибками
		if($offset===false){// действия если изначальный сдвиг не указан
			$this->_errorPointsArray[$name] = $cnt;// сдвиг присваивается равным количеству элементов массива
		}else{// действия если изначальный сдвиг указан
			if($offset<0){// если изначальный сдвиг ошибочный и < 0
				$this->_errorPointsArray[$name] = 0;// сдвиг присваивается равным 0
			}else{
				$this->_errorPointsArray[$name] = $offset;// сдвиг присваивается равным указанному числу элементов
			}
		}
	}
	function getNewErrors($name=false){// метод возвращающий срез массива с новыми ошибками или false в случае отсутствия ошибок
		// $name - имя точки проверки
		if($name===false)
			$name = $this->_lastSetErrorKey;
		if(count($this->_errors)>$this->_errorPointsArray[$name])// действия, если ошибки есть, начиная с указанного индекса
			return array_slice($this->_errors,$this->_errorPointsArray[$name]);// возврат среза массива с ошибками, начиная с указанного элемента
		return false;// если новые ошибки отсутствуют, возвращается false
	}
	private function escapeTags($mass){// метод замены запрещенных символов на HTML сущности в элементах массива
		// $mass - анализируемый массив
		foreach ($mass as $key => $value) {
			if(is_array($value)){// если элемент массива также является массивов, выполняется рекурсивный вызов метода замена запрещенных символов на HTML сущности
				$mass["$key"] = $this->escapeTags($value);
			}else{
				$mass["$key"] = htmlspecialchars($value);// замена запрещенных символов на HTML сущности
			}
		}
		return $mass;
	}
	private function setDataFromConfigFile(){// метод для установка параметров из конфигурационного файла
		$this->_routes = $GLOBALS["routingRules"];// копирование с конфигурационного файла ассоциативного массива с маршрутами, связывающие строку запроса с котроллерами и их методами
		$this->_defaultController = $GLOBALS["defaultController"];// копирование с конфигурационного файла имя контроллера по умолчанию
		$this->_errorController = $GLOBALS["errorController"];// копирование с конфигурационного файла имя контроллера обрабатывающего ошибку 404
		foreach ($GLOBALS["includes"] as $value)// подключение дополнительных файлов указанных в конфигурационном файле
			require_once "application/libraries/".$value;
	}
	private function __construct(){//создание экземпляра класса FrontController
		$this->setDataFromConfigFile();// установка параметров из конфигурационного файла
		$request = trim($_SERVER['REQUEST_URI'],"/");// получение строки запроса
		if($GLOBALS["serverName"]!=""){// если указанно доменное имя, необходимо обработать запрос
			$request = $_SERVER['SERVER_NAME']."/".$request;// создание полного адреса запроса
			$serverName = trim($GLOBALS["serverName"],"http://");// получение доменного имени сайта, указанного пользователем
			$serverName = trim($serverName,"/");
			$request = str_replace($serverName, "", $request);// удаление доменного имени из строки запроса
			$request = trim($request,"/");
		}
		$findeRoute = true;// флаг найденного маршрута в массиве из файла config.php
		foreach ($this->_routes as $key => $value){// проверка указанного запроса на наличие совпадений с маршрутами
			$findeRoute = true;// Перед проверками установка флага в значение true
			$key = trim($key,"/");
			if(is_array($value)){// если $value является массивом, тогда выполняется сложная проверка
				if(!isset($value["post"]) and !isset($value["get"]) and !isset($value["cookie"]) and !isset($value["session"]) and !isset($value["server"]) and !isset($value["action"])){//проверка наличия зарезервированных ключей
					// Когда зарезервированные ключи отсутствуют, это значит что указано регулярное выражение для проверки строки запроса
					$requestNew = preg_replace($value[0], $key, $request);// Выполняется замена в строке запроса
					if($requestNew!=$request){// Проверка совпадения новой строки запроса со старой
						// Если новая строка запроса не совпадает со старой, это означает что правило подходит под запрос
						$request = $requestNew;// Замена существующей строки на новою
						break;// Прекращение проверки правил
					}else{
						// Если новая строка запроса совпадает со старой, это означает что правило не подходит под запрос
						continue;// переход к проверки следующего правила
						$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
					}
				}else{
					// Когда зарезервированные ключи обнаружены, это означает необходимо выполнить проверки связанные с указанными зарезервированными ключами
					$tempRequest = $request;// Создание дополнительной переменной, в какой храниться запрос для манипуляций с ним
					if(isset($value["action"])){// Проверка наличия ключа "action"
						// При наличии ключа, необходимо проверить указанный контроллер и его метод на соответствие
						if(is_array($value["action"])){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
							// Если указан массив, необходимо выполнить проверку соответствия регулярному выражению и при совпадении - выполнить замену
							$tempRequest = preg_replace($value["action"][0], $key, $request);// Выполняется замена во временной строке запроса при совпадении
							if($tempRequest===$request){// Проверка наличия изменений в строке запроса
								continue;// Если изменения не обнаружены, это означает, что строка запроса не соответствует указанному регулярному выражению. Выполняется переход к проверки следующего правила
								$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
							}
						}else{
							// Если указан не массив, необходимо проверить точное совпадение
							$value["action"] = trim($value["action"],"/");// Удаление символа "/" в начале и конце строки
							if($value["action"]=="" and $tempRequest==""){// Если значение в массиве маршрутов ровняется пустой строке и запрос так же равен постой строке, выполняется замена
								$tempRequest = $key;// Выполняется замена на указанное в массиве значение
							}else{
								if($value["action"]!="" and strpos($tempRequest,$value["action"])===0){// если совпадение обнаружено и находиться в начале, производиться замена
									$tempRequest = str_replace($value["action"], $key, $tempRequest);// замена на указанный маршрут в массиве маршрутов
								}else{
									continue;// Если совпадения не обнаружены, это означает, что строка запроса не соответствует указанному. Выполняется переход к проверки следующего правила.
									$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
								}
							}
						}
					}
					if(isset($value["params"])){// Выполняется проверка параметров, если правила указаны в значении с ключем params
						$tempRequestMass = explode("/",$tempRequest);// Из временного запроса создается массив, разделителем служит "/"
						$tempParams = array();// Создание временного массива хранящего параметры
						for($i=2,$cnt=count($tempRequestMass);$i<$cnt;$i++)// Заполнение временного массива параметров
							$tempParams[] = urldecode($tempRequestMass[$i]);
						unset($tempRequestMass);// Удаление из памяти переменной с массивом из временной строки запроса
						if(count($tempParams)!==0){// Проверка наличия переданных параметров через строку запроса
							$stopThisRule = false;// Установка флага необходимости прекращения проверки этого правила в положение false
							foreach ($value["params"] as $paramKey => $paramValue) {// Проверка подтверждения каждого правила
								if(!isset($tempParams[$paramKey])){// Проверка наличия переменной во временном массиве параметров
									$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
									$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
									break;// Выход из цикла проверки параметров
								}else{
									// Если параметр существует, выполняется дальнейшая проверка
									if(is_array($paramValue)){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
										if(!preg_match($paramValue[0],$tempParams[$paramKey])){// Выполняется проверка соответствия регулярного выражения значению
											// При не соответствии
											$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
											$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
											break;// Выход из цикла проверки параметров
										}
									}else{
										// Если указан не массив, необходимо проверить точное совпадение
										if($paramValue!==null){// Проверка необходимости сравнения
											if($tempParams[$paramKey]!=$paramValue){// Проверка совпадения значений
												$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
												$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
												break;// Выход из цикла проверки параметров
											}
										}
									}
								}
							}
							if($stopThisRule)// Проверка флага необходимости окончания текущей проверки
								continue;// Переход к следующему правилу
						}else{
							// При отсутствии переданных значений
							continue;// Переход к следующему правилу
						}
					}
					if(isset($value["get"])){// Выполняется проверка параметров, если правила указаны в значении с ключем get
						$stopThisRule = false;// Установка флага необходимости прекращения проверки этого правила в положение false
						foreach ($value["get"] as $paramKey => $paramValue) {// Проверка подтверждения каждого правила
							if(!isset($_GET[$paramKey])){// Проверка наличия переменной во временном массиве параметров
								$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
								$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
								break;// Выход из цикла проверки параметров
							}else{
								// Если параметр существует, выполняется дальнейшая проверка
								if(is_array($paramValue)){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
									if(!preg_match($paramValue[0],$_GET[$paramKey])){// Выполняется проверка соответствия регулярного выражения значению
										// При не соответствии
										$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
										$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
										break;// Выход из цикла проверки параметров
									}
								}else{
									// Если указан не массив, необходимо проверить точное совпадение
									if($paramValue!==null){// Проверка необходимости сравнения
										if($_GET[$paramKey]!=$paramValue){// Проверка совпадения значений
											$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
											$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
											break;// Выход из цикла проверки параметров
										}
									}

								}
							}
						}
						if($stopThisRule)// Проверка флага необходимости окончания текущей проверки
							continue;// Переход к следующему правилу
					}
					if(isset($value["post"])){// Выполняется проверка параметров, если правила указаны в значении с ключем "post"
						$stopThisRule = false;// Установка флага необходимости прекращения проверки этого правила в положение false
						foreach ($value["post"] as $paramKey => $paramValue) {// Проверка подтверждения каждого правила
							if(!isset($_POST[$paramKey])){// Проверка наличия переменной во временном массиве параметров
								$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
								$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
								break;// Выход из цикла проверки параметров
							}else{
								// Если параметр существует, выполняется дальнейшая проверка
								if(is_array($paramValue)){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
									if(!preg_match($paramValue[0],$_POST[$paramKey])){// Выполняется проверка соответствия регулярного выражения значению
										// При не соответствии
										$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
										$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
										break;// Выход из цикла проверки параметров
									}
								}else{
									// Если указан не массив, необходимо проверить точное совпадение
									if($paramValue!==null){// Проверка необходимости сравнения
										if($_POST[$paramKey]!=$paramValue){// Проверка совпадения значений
											$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
											$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
											break;// Выход из цикла проверки параметров
										}
									}
								}
							}
						}
						if($stopThisRule)// Проверка флага необходимости окончания текущей проверки
							continue;// Переход к следующему правилу
					}
					if(isset($value["cookie"])){// Выполняется проверка параметров, если правила указаны в значении с ключем "cookie"
						$stopThisRule = false;// Установка флага необходимости прекращения проверки этого правила в положение false
						foreach ($value["cookie"] as $paramKey => $paramValue) {// Проверка подтверждения каждого правила
							if(!isset($_COOKIE[$paramKey])){// Проверка наличия переменной во временном массиве параметров
								$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
								$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
								break;// Выход из цикла проверки параметров
							}else{
								// Если параметр существует, выполняется дальнейшая проверка
								if(is_array($paramValue)){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
									if(!preg_match($paramValue[0],$_COOKIE[$paramKey])){// Выполняется проверка соответствия регулярного выражения значению
										// При не соответствии
										$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
										$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
										break;// Выход из цикла проверки параметров
									}
								}else{
									// Если указан не массив, необходимо проверить точное совпадение
									if($paramValue!==null){// Проверка необходимости сравнения
										if($_COOKIE[$paramKey]!=$paramValue){// Проверка совпадения значений
											$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
											$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
											break;// Выход из цикла проверки параметров
										}
									}
								}
							}
						}
						if($stopThisRule)// Проверка флага необходимости окончания текущей проверки
							continue;// Переход к следующему правилу
					}
					if(isset($value["server"])){// Выполняется проверка параметров, если правила указаны в значении с ключем "server"
						$stopThisRule = false;// Установка флага необходимости прекращения проверки этого правила в положение false
						foreach ($value["server"] as $paramKey => $paramValue) {// Проверка подтверждения каждого правила
							if(!isset($_SERVER[$paramKey])){// Проверка наличия переменной во временном массиве параметров
								$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
								$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
								break;// Выход из цикла проверки параметров
							}else{
								// Если параметр существует, выполняется дальнейшая проверка
								if(is_array($paramValue)){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
									if(!preg_match($paramValue[0],$_SERVER[$paramKey])){// Выполняется проверка соответствия регулярного выражения значению
										// При не соответствии
										$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
										$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
										break;// Выход из цикла проверки параметров
									}
								}else{
									// Если указан не массив, необходимо проверить точное совпадение
									if($paramValue!==null){// Проверка необходимости сравнения
										if($_SERVER[$paramKey]!=$paramValue){// Проверка совпадения значений
											$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
											$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
											break;// Выход из цикла проверки параметров
										}
									}
								}
							}
						}
						if($stopThisRule)// Проверка флага необходимости окончания текущей проверки
							continue;// Переход к следующему правилу
					}
					if(isset($value["session"])){// Выполняется проверка параметров, если правила указаны в значении с ключем "session"
						$stopThisRule = false;// Установка флага необходимости прекращения проверки этого правила в положение false
						foreach ($value["session"] as $paramKey => $paramValue) {// Проверка подтверждения каждого правила
							if(!isset($_SESSION[$paramKey])){// Проверка наличия переменной во временном массиве параметров
								$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
								$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
								break;// Выход из цикла проверки параметров
							}else{
								// Если параметр существует, выполняется дальнейшая проверка
								if(is_array($paramValue)){// Проверка необходимости выполнения сравнения используя регулярное выражения, когда указан массив или простое сравнение
									if(!preg_match($paramValue[0],$_SESSION[$paramKey])){// Выполняется проверка соответствия регулярного выражения значению
										// При не соответствии
										$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
										$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
										break;// Выход из цикла проверки параметров
									}
								}else{
									// Если указан не массив, необходимо проверить точное совпадение
									if($paramValue!==null){// Проверка необходимости сравнения
										if($_SESSION[$paramKey]!=$paramValue){// Проверка совпадения значений
											$stopThisRule = true;// Установка флага в положение необходимости прекращения проверки для этого правила
											$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
											break;// Выход из цикла проверки параметров
										}
									}
								}
							}
						}
						if($stopThisRule)// Проверка флага необходимости окончания текущей проверки
							continue;// Переход к следующему правилу
					}
					// Если выполнение дошло до этого метса, значит все проверки удачно пройдены и это правило соответствует запросу. Можно остановить дальнейшую проверку правил.
					$request = $tempRequest;//Замена строки запроса на обработанную
					if(isset($value["escHTMLVariables"]))// Проверка необходимости изменения правила экранирования HTML символов
						$GLOBALS["escHTMLVariables"] = $value["escHTMLVariables"];// Глобальной переменной, отвечающей за необходимость экранирования, присваивается новое значение.
					break;// Прекращение дальнейших проверок правил
				}
			}else{
				$value = trim($value,"/");
				if($value=="" and $request==""){// Если значение в массиве маршрутов ровняется пустой строке и запрос так же равен постой строке, выполняется замена
					$request = $key;// Выполняется замена на указанное в массиве значение
					break;// Прекращение дальнейших проверок правил
				}
				if($value!="" and strpos($request,$value)===0){// если совпадение обнаружено и находиться в начале, производиться замена
					$request = str_replace($value, $key, $request);// замена на указанный маршрут в массиве маршрутов
					break;// Прекращение дальнейших проверок правил
				}else{
					$findeRoute = false;// При не совпадении маршрута, установка флага в значение false
				}
			}
		}
		if($findeRoute==false and $GLOBALS["useDirectRoute"]==false)
			$request = "-1/-1";
		$requestMass = explode("/",$request);
		unset($request);
		if($requestMass[count($requestMass)-1]=="__request__"){// код выполняемый при системном запросе
			$this->_requestType = "remote";// установка типа системного запроса
			$requestMass = array_slice($requestMass,0,count($requestMass)-1);
			$allDatRequest = json_decode($_POST["allVar"],true);// создание массива внутренних переменных
			unset($_POST["allVar"]);
			foreach ($allDatRequest as $key => $value){
				foreach ($value as $key2 => $value2) {
					if($key=="post")
						$_POST["$key2"] = $value2;
					if($key=="get")
						$_GET["$key2"] = $value2;
					if($key=="cookie")
						$_COOKIE["$key2"] = $value2;
					if($key=="session")
						$_SESSION["$key2"] = $value2;
				}
			}
			unset($allDatRequest);
		}
		if($GLOBALS["escHTMLVariables"]==true){// проверка необходимости замены специальных символов на HTML сущности
			if($this->_requestType==="none"){// замена запрещенных символов на HTML сущности
				$_POST = $this->escapeTags($_POST);
				$_GET = $this->escapeTags($_GET);
				$_COOKIE = $this->escapeTags($_COOKIE);
				if(isset($_SESSION))
					$_SESSION = $this->escapeTags($_SESSION);
			}
		}
		$this->createRouteData($requestMass);// вызов метода создания исходных данных для дальнейшей обработки
	}
	private function createRouteData($requestMass){// разбор строки запроса и создание исходных данных лдя дальнейшей обработки
		// $requestMass - массив содержащий элементы строки запроса
		$this->_controller = !empty($requestMass[0])?ucfirst(strtolower(urldecode($requestMass[0])))."Controller":$this->_defaultController;// имя вызываемого контроллера
		$this->_action = !empty($requestMass[1])?strtolower(urldecode($requestMass[1]))."Action":null;// имя вызываемого метода контроллера
		if(!empty($_GET)){// если массив $_GET не пустой, необходимо проверить попадания переменных $_GET в имя метода
			if(strpos($this->_action, "?")!==false){
				$this->_action = preg_replace('/\?.*/', "", $this->_action);// Отбрасывается все, что относиться к массиву $_GET
				$this->_action .= "Action";// Добавление слова "Action" в конец строки
				if($this->_action=="Action")// Если метод контроллера не указан, используется метод по умолчанию
					$this->_action = null;
			}
			if(strpos($this->_controller, "?")!==false){
				$this->_controller = preg_replace('/\?.*/', "", $this->_controller);// Отбрасывается все, что относиться к массиву $_GET
				$this->_controller .= "Controller";// Добавление слова "Controller" в конец строки
				if($this->_controller=="Controller")// Если контроллер не указан, используется контроллер по умолчанию
					$this->_controller = $this->_defaultController;
			}
		}
		for($i=2,$cnt=count($requestMass);$i<$cnt;$i++){// создание массива параметров
			$this->_params[] = urldecode($requestMass[$i]);
		}
		if($GLOBALS["escHTMLVariables"]==true)// проверка необходимости замены специальных символов на HTML сущности
			$this->_params = $this->escapeTags($this->_params);// замена запрещенных символов на HTML сущности в массиве параметров
	}
	function route(){//метод инициализирующий выполнение указанной модели поведения
		$showController = null;
		$controller = null;//экземпляр класса исполняемого контроллера
		if(class_exists($this->_controller)){// проверка наличия указанного контроллера
			$showController = new ReflectionClass($this->_controller);
			$controller = $showController->newInstance();
			if($this->_action==null)// установка метода по умолчанию в случае если он не указан
				$this->_action = $controller->_defaultAction;
		}else{
			$this->_needReturn404Error = true;// установка флага, что необходимо передать заголовки 404-й ошибки
			if(!class_exists($this->_errorController))// проверка наличия контроллера обработки ошибок
				$this->show404Page("<strong>Системная ошибка (009): не найден указанный контроллер \"".$this->_controller."\" и контроллер для обработки ошибок \"".$this->_errorController."\".</strong>",true);
			if($this->_requestStopText!=="")// если режим системного запроса (удаленного или локального), прерывание выполнения
				return false;
			$showController = new ReflectionClass($this->_errorController);// создается класс с информацией о контроллере
			$this->_controller = $this->_errorController;
			$controller = $showController->newInstance();// создается экземпляр класса контроллера
			$this->_action = $controller->_errorAction;
		}
		if(!$showController->hasMethod($this->_action)){// если вызывается не существующий метод указанного контроллера, устанавливается метод обработки ошибки этого контроллера
			$this->_action = $controller->_errorAction;
			$this->_needReturn404Error = true;// установка флага, что необходимо передать заголовки 404-й ошибки
		}
		if(!$showController->hasMethod($this->_action)){// если в указанном контроллере метод обработки ошибки не существует, устанавливается контроллер обработки ошибки и его метод обработки ошибки
			$this->_needReturn404Error = true;// установка флага, что необходимо передать заголовки 404-й ошибки
			if($this->_errorController==$this->_controller)// действия если в контроллере обработки 404-й ошибки нет метода обработки этой ошибки
				$this->show404Page("<strong>Системная ошибка (004): не найден метод обработки ошибок в контроллере \"".$this->_errorController."\".</strong>",true);
			if($this->_requestStopText!=="")// если режим системного запроса (удаленного или локального), прерывание выполнения
				return false;
			if($this->_errorController!=$this->_controller){// действия если в установленном нет метода обработки ошибки 404
				if(!class_exists($this->_errorController))// проверка наличия контроллера обработки ошибок
					$this->show404Page("<strong>Системная ошибка (009): не найден указанный контроллер \"".$this->_controller."\" и контроллер для обработки ошибок \"".$this->_errorController."\".</strong>",true);
				if($this->_requestStopText!=="")// если режим системного запроса (удаленного или локального), прерывание выполнения
					return false;
				$showController = new ReflectionClass($this->_errorController);// создается класс с информацией о контроллере
				$this->_controller = $this->_errorController;
				$controller = $showController->newInstance();// создается экземпляр класса контроллера
				$this->_action = $controller->_errorAction;
				if(!$showController->hasMethod($this->_action))
					$this->show404Page("<strong>Системная ошибка (004): не найден метод обработки ошибок в контроллере \"".$this->_errorController."\".</strong>",true);
				if($this->_requestStopText!=="")// если режим системного запроса (удаленного или локального), прерывание выполнения
					return false;
			}
			if($this->_requestStopText!=="")// если режим системного запроса (удаленного или локального), прерывание выполнения
				return false;
		}
		$method = $showController->getMethod($this->_action);
		if(method_exists("Events","beforeAction"))// если существует метод в классе событий, вызов его
			Events::beforeAction();// вызов метода из класса событий
		$method->invoke($controller);// вызов модели поведения
	}
	function getPage(){// возвращает содержимого, что будет передано в браузер
		return $this->_page;
	}
	function setPage($dat=false){// присваивает содержимое страницы
		// $dat - текст какой необходимо установить для передачи в браузер
		if($dat===false)
			return false;
		$this->_page = $dat;
	}
	function parametersParsing($method="default 2",$params=null,$userPattern=""){// метод парсинга параметров полученных через строку запроса
		// $method - метод обработки параметров
		// $params - массив с параметрами, какие необходимо обработать
		// $userPattern - паттерн по какому выполнять обработку, если метод пользовательский()
		if($params==null)// если массив с данными не передан
			$params = $this->_params;// в массив что обрабатывается копируется массив с параметрами принятыми через строку запроса
		$sortParams = array();// массив с обработанными параметрами
		switch ($method) {
			case 'default 1':// обработка параметров в соответствии паттерна "ключ"=>"значение"
				$paramsCount = count($params);
				if(($paramsCount%2)!=0){// проверка правильности полученного массива (парное количество элементов массива)
					$this->_errors[] = array("006","Не удалось создать массив параметров в формате \"key\" => \"value\", не четное количество параметров.");// сохранение кода и текста ошибки в массив ошибок
					return false;
				}
				for($i=0;$i<$paramsCount;$i++){// создание ассоциативного массива с полями "ключ" - непарный индекс массива параметров (начиная с 0), "значение" - парный индекс массива параметров
					if(($i%2)!==0){// когда индекс парный добавляется новый элемент массива
						$sortParams[$params[$i-1]] = $params[$i];
					}
				}
				break;
			case 'default 2':// обработка параметров в соответствии паттерна "индекс"=>"значение"
				return($params);// при этом паттерне обработка не требуется
				break;
			case 'user':// обработка параметров в соответствии пользовательского паттерна
				if($userPattern===""){// если паттерн пустой возвращается ошибка
					$this->_errors[] = array("007","Не удалось создать массив параметров.");// сохранение кода и текста ошибки в массив ошибок
					return array("007","Не удалось создать массив параметров.");
				}
				break;
		}
		return($sortParams);// возвращение обработанного массива параметров
	}
	function createHTML($tmp,$params=null){// метод создания HTML текста из шаблона
		// $tmp - имя шаблона
		// $params - массив с переменными, замена каких произойдет в шаблоне
		if(!file_exists("application/templates/".$tmp)){// действия при отсутствии файла шаблона
			$this->_errors[] = array("041","Не удалось найти файл шаблона.");// сохранение кода и текста ошибки в массив ошибок
			return false;// при отсутствии файла шаблона - возвращается пустая строка
		}
		if(stripos($tmp, ".htm")!==false){// если используется HTML файл, он обрабатывается как шаблон
			$fileData = file_get_contents("application/templates/".$tmp);// получение данных из файла шаблона
			if($params!==null){// в случае, если массив с передаваемыми параметрами существует происходит замена переменных в шаблоне
				foreach ($params as $key => $value) {
					$fileData = str_replace("<:$key:>", $value, $fileData);// замена ключей в шаблоне на значения их соответствующих переменных
				}
			}
			return $fileData;
		}
		if(stripos($tmp, ".php")!==false){// если используется php файл происходит буферизация при его непосредственном подключении
			ob_start();// включение буферизации вывода
			include("application/templates/".$tmp);// подключение файла шаблона
			return ob_get_clean();// возвращение содержимого буфера и его очистка
		}
		$this->_errors[] = array("041","Не правильно указан формат файла.");// сохранение кода и текста ошибки в массив ошибок
		return "";// при неизвестном типе файла шаблона - возвращается пустая строка
	}
	function request($str){// метод выполняющий системный запрос к контроллеру
		// $str - строка запроса
		$pos = stripos($str, "http://");
		if($pos!==false){// действия при выполнении удаленного системного запроса
			$url = substr($str,$pos+7);// создание url без "http://"
			$urlMass = explode("/",trim($url,"/"));// создание массива из элементов строки запроса, разделенных символом "/"
			//$add = false;
			$url = "";
			$dom = $urlMass[0];// доменное имя
			foreach ($urlMass as $key => $value){// создание строки запроса
				if($key>0)
					$url .= "/".$value;
			}
			$url .= "/__request__";// добавление идентификатора, определяющего, что запрос системный
			$allMass = array(// создание массива со всеми входящими параметрами
				"post"=>$_POST,
				"get"=>$_GET,
				"cookie"=>$_COOKIE
			);
			if(isset($_SESSION))// в случае наличия переменных в массиве $_SESSION добавление их в массив со всеми входящими параметрами
				$allMass["session"] = $_SESSION;
			$fs = fsockopen($dom, 80, $errno, $errstr, 30);// открытие сокет соединения
			if(!$fs){// в случае, если соединение установить не удалось, возвращается ошибка
				$this->_errors[] = array("021","Ошибка открытия соединения.");// сохранение кода и текста ошибки в массив ошибок
				return array("021","Ошибка открытия соединения.");
			}
			$sendData = "";
			$sendData = "allVar=".urlencode(json_encode($allMass))."\r\n";// создание JSON строки, передаваемой в POST запросе
			$send = "POST $url HTTP/1.0\r\n";// создание заголовков запроса
			$send .= "Host: $dom\r\n";
			$send .= "Content-type: application/x-www-form-urlencoded\r\n";
			$send .= "Content-length: ".strlen($sendData)."\r\n";
			$send .= "Connection: Close\r\n\r\n";
			$send .= $sendData."\r\n\r\n";
			fwrite($fs, $send);// отправка запроса
			$returRequestData = '';
			while(!feof($fs)){// ожидание ответа сервера
				$returRequestData .= fgets($fs,128);
			}
			fclose($fs);// закрытие соединения с сервером
			$pos = strpos($returRequestData, "\r\n\r\n");// определение позиции контента
			$returRequestData = substr($returRequestData, $pos+4);// извлечение контента из ответа сервера
			$returRequestData2 = json_decode($returRequestData,true);// данных полученных от сервера
			//return $returRequestData2["_body"];
			return array("_page"=>$returRequestData2["_page"],"_requestReturnData"=>$returRequestData2["_requestReturnData"],"_errors"=>$returRequestData2["_errors"],"_requestStopText"=>$returRequestData2["_requestStopText"]);// возврат параметров и сгенерированного текста страницы системного запроса
		}
		$requestMass = explode("/",trim($str,"/"));// создание массива из элементов строки запроса, разделенных символом "/"
		$dat = $this->createFCData();// сохранение всех параметров главного контроллера в переменную
		$this->_requestType = "local";// перевод работы контроллера в режим локального запроса
		$this->createRouteData($requestMass);// вызов метода создания исходных данных для дальнейшей обработки
		$this->route();// выполнение указаной модели поведения
		$retData = array("_page"=>$this->_page,"_requestReturnData"=>$this->_requestReturnData,"_errors"=>$this->_errors,"_requestStopText"=>$this->_requestStopText);// создание массива с параметрами и сгенерированным текстом страницы системного запроса
		$this->setFCData($dat);// восстановление параметров главного контроллера
		return $retData;// возврат данных
	}
	private function createFCData(){// метод сохранения всех параметров главного контроллера в переменную
		return array(
			"_controller"=>$this->_controller,// имя или экземпляр класса вызываемого контроллера
			"_errorPointsArray"=>$this->_errorPointsArray,// массив с позициями в массиве _errors с каких проверяется наличие новых ошибок
			"_lastSetErrorKey"=>$this->_lastSetErrorKey,// ключ массива _errorPointsArray, какой был установлен последним
			"_action"=>$this->_action,// имя вызываемой модели поведения
			"_page"=>$this->_page,// сгенерированная страница
			"_view"=>$this->_view,// имя представления, какое используется по умолчанию
			"_isBody"=>$this->_isBody,// флаг наличия содержимого страницы
			"_openRemoteConnect"=>$this->_openRemoteConnect,// флаг возможности удаленных системных запросов
			"_defaultController"=>$this->_defaultController,// имя контроллера, вызываемого по умолчанию
			"_errorController"=>$this->_errorController,// имя контроллера, вызываемого при отсутствии указанного котроллера
			"_routes"=>$this->_routes,// ассоциативный массив с маршрутами, связывающие строку запроса с котроллерами и их методами
			"_errors"=>$this->_errors,// массив с не критическими ошибками
			"_needReturn404Error"=>$this->_needReturn404Error,// флаг при котором необходимо передать браузеру заголовки 404-й ошибки
			"_params"=>$this->_params,// параметры, переданные в строке запроса.
			"_remoteIp"=>$this->_remoteIp,// массив с ip адресами, с каких разрешено выполнять удаленный системный запрос
			"_requestType"=>$this->_requestType,// тип системного запроса
			"_requestStopText"=>$this->_requestStopText,// текст критической ошибки, при системном запросе
			"_requestReturnData"=>$this->_requestReturnData// переменная, значение какой передается обратно при системном запросе
		);
	}
	private function setFCData($dat){// метод восстановления параметров главного контроллера
		// $dat - массив с новыми параметрами глобального контроллера
		$this->_controller = $dat["_controller"];// имя или экземпляр класса вызываемого контроллера
		$this->_errorPointsArray = $dat["_errorPointsArray"];// массив с позициями в массиве _errors с каких проверяется наличие новых ошибок
		$this->_lastSetErrorKey = $dat["_lastSetErrorKey"];// ключ массива _errorPointsArray, какой был установлен последним
		$this->_action = $dat["_action"];// имя вызываемой модели поведения
		$this->_page = $dat["_page"];// сгенерированная страница
		$this->_view = $dat["_view"];// имя представления, какое используется по умолчанию
		$this->_isBody = $dat["_isBody"];// флаг наличия содержимого страницы
		$this->_openRemoteConnect = $dat["_openRemoteConnect"];// флаг возможности удаленных системных запросов
		$this->_defaultController = $dat["_defaultController"];// имя контроллера, вызываемого по умолчанию
		$this->_errorController = $dat["_errorController"];// имя контроллера, вызываемого при отсутствии указанного котроллера
		$this->_routes = $dat["_routes"];// ассоциативный массив с маршрутами, связывающие строку запроса с котроллерами и их методами
		$this->_errors = $dat["_errors"];// массив с не критическими ошибками
		$this->_needReturn404Error = $dat["_needReturn404Error"];// флаг при котором необходимо передать браузеру заголовки 404-й ошибки
		$this->_params = $dat["_params"];// параметры, переданные в строке запроса.
		$this->_remoteIp = $dat["_remoteIp"];// массив с ip адресами, с каких разрешено выполнять удаленный системный запрос
		$this->_requestType = $dat["_requestType"];// тип системного запроса
		$this->_requestStopText = $dat["_requestStopText"];// текст критической ошибки, при системном запросе
		$this->_requestReturnData = $dat["_requestReturnData"];// переменная, значение какой передается обратно при системном запросе
	}
	function show404Page($text,$isSystemError=false){// метод генерации ошибки 404
		// $text - текст выводимый в окне браузера
		$check = php_sapi_name();
		if($check=='cgi' || $check=='cgi-fcgi'){
			header('Status: 404 Not Found');// отправка заголовка с 404-й ошибкой
		}else{
			header($_SERVER['SERVER_PROTOCOL'].' 404 Not Found');// отправка заголовка с 404-й ошибкой
		}
		if($this->_requestType==="none"){// проверка типа запроса (системный или пользовательский)
			if($isSystemError==true and $GLOBALS["onProduction"]==false)// проверка необходимости вывода системной ошибки
				exit();
			die($text);// при пользовательском запросе отправка текст страницы и остановка роботы приложения
		}else{
			$this->_requestStopText = $text;// при системном запросе сохранение текста
		}
	}
}